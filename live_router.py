# live_router.py (Upgraded to use the high-speed SQLite database)
import sqlite3
import time
import os

class LiveRouter:
    def __init__(self, all_routes_db_path):
        """
        Initializes the LiveRouter by connecting to the pre-calculated routes database.
        :param all_routes_db_path: Path to the SQLite DB file generated by the new script.
        """
        if not os.path.exists(all_routes_db_path):
            raise FileNotFoundError(f"Database file not found at '{all_routes_db_path}'. Please run the generator script first.")

        print(f"Connecting to pre-calculated routes database: '{all_routes_db_path}'...")
        start_time = time.time()
        
        # Connect to the SQLite database. This is an instant operation.
        self.db_path = all_routes_db_path
        
        end_time = time.time()
        print(f"Database connection established in {end_time - start_time:.4f} seconds.")
        print("--------------------------------------------------")
        print("Live Router is ready. Enter 'quit' at any time to exit.")
        print("--------------------------------------------------")

    def get_route_recommendation(self, start_id, end_id, live_traffic_status):
        """
        Provides a route recommendation by querying the database for the pre-calculated path.
        """
        print(f"\n--- Finding best route from {start_id} to {end_id} ---")
        
        # A new connection is opened and closed for each query, which is a robust pattern.
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # The query uses the index we created for a super-fast lookup.
        # We use placeholders (?) to prevent SQL injection.
        query = "SELECT shortest_path_stops FROM routes WHERE start_id = ? AND end_id = ?"
        cursor.execute(query, (str(start_id), str(end_id)))
        result = cursor.fetchone() # Fetches the first (and only) result
        
        conn.close()

        if result is None:
            print(f"\nERROR: No pre-calculated route found between {start_id} and {end_id}.")
            print("This indicates the two stops are not connected in our generated graph.")
            return

        path_str = result[0]
        path_list = path_str.split('->')
        print(f"Pre-calculated shortest path: {path_str}")
        
        # The rest of your logic for traffic alerts is perfect and remains unchanged.
        recommendations = []
        is_congested = False
        
        for stop in path_list:
            if stop in live_traffic_status:
                status = live_traffic_status[stop]
                if status == 'red':
                    recommendations.append(f"WARNING: Heavy congestion at/near stop {stop}. Expect major delays.")
                    is_congested = True
                elif status == 'yellow':
                    recommendations.append(f"ALERT: Moderate congestion at/near stop {stop}. Expect minor delays.")
                    is_congested = True
        
        if not is_congested:
            recommendations.append("Path appears clear of major traffic.")

        print("\n--- Final Recommendation ---")
        print(f"Optimal Path: {' -> '.join(path_list)}")
        print("Driver Alerts:")
        for alert in recommendations:
            print(f"  - {alert}")

# =============================================================================
# --- Main Interactive Loop ---
# =============================================================================
if __name__ == "__main__":
    # --- IMPORTANT: We now point to the .db file, not the .csv file! ---
    ALL_ROUTES_FILE = 'all_routes_bronx.db'
    
    try:
        router = LiveRouter(ALL_ROUTES_FILE)
    except FileNotFoundError as e:
        print(e)
        # Exit the script if the database can't be found.
        exit()

    # --- SIMULATE getting live traffic data ---
    fake_live_traffic = {
        '104087': 'red',
        '104088': 'green',
        '103449': 'yellow'
    }
    print(f"Using simulated live traffic: {fake_live_traffic}\n")

    while True:
        start_input = input("Enter the START stop ID (or 'quit' to exit): ")
        if start_input.lower() == 'quit':
            break

        end_input = input("Enter the END stop ID (or 'quit' to exit):   ")
        if end_input.lower() == 'quit':
            break

        router.get_route_recommendation(start_input, end_input, fake_live_traffic)
        
        print("\n--------------------------------------------------")